/* Lux, a Fintal Fantasy XIV Dalamud plugin         .____     ____ _______  ___
 *      for rich cartography interfaces.            |    |   |    |   \   \/  /
 *                                                  |    |   |    |   /\     / 
 * Package: Lux.Common                              |    |___|    |  / /     \ 
 * Author:  Harold Iedema <harold@iedema.me>        |_______ \______/ /___/\  \
 * -------------------------------------------------------- \/              \*/

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;
using Dalamud.Plugin;

namespace Lux.Common.Model;

[Service]
public class ModelRepository : IDisposable
{
    private readonly Dictionary<Type,   string> _names    = [];
    private readonly Dictionary<string, Dictionary<string, int>> _offsets = [];
    private readonly List<Type> _enumTypes = [];
    private readonly Dictionary<string, string> _extendedTypes = [];

    public ModelRepository(AssemblyList assemblyList, DalamudPluginInterface plugin)
    {
        assemblyList.PluginAssembly.GetTypes()
            .Where(t => t.GetCustomAttribute<Model>() != null)
            .ToList().ForEach(RegisterModel);

        if (plugin.IsDev) {
            Logger.Info("Plugin is in development mode. Building TypeScript models...");
            IndexModelExtensions(plugin);
            BuildTypeScriptModels(plugin);
        }
    }

    public void Dispose()
    {
    }

    public bool IsModel(object? model)
    {
        return model != null && _offsets.ContainsKey(model.GetType().Name);
    }

    public Dictionary<string, int> GetOffsets(object model)
    {
        var name = model.GetType().Name;

        if (!_offsets.ContainsKey(name)) {
            throw new Exception($"Model '{name}' not found.");
        }

        return _offsets[name];
    }

    private void IndexModelExtensions(DalamudPluginInterface plugin)
    {
        var baseDir = new DirectoryInfo(Path.Combine(plugin.AssemblyLocation.DirectoryName!, "..\\ui\\src"));
        var files   = baseDir.GetFiles("*.ts", SearchOption.AllDirectories);

        foreach (var file in files) {
            var content = File.ReadAllText(file.FullName);
            var matches = Regex.Matches(content, @"@ModelExtension\('([^']+)'\)");
            
            foreach (Match match in matches.Cast<Match>()) {
                var name = match.Groups[1].Value;
                var path = "@" + file.FullName.Replace(baseDir.FullName, "").Replace("\\", "/").Replace(".ts", "");
                _extendedTypes[name] = path;
            }
        }
    }

    private void RegisterModel(Type type)
    {
        _names[type]        = type.Name;
        _offsets[type.Name] = [];
        
        var fields = type.GetFields().Where(f => f.GetCustomAttribute<Offset>() != null).ToList();

        foreach (var field in fields)
        {
            _offsets[type.Name][field.Name] = field.GetCustomAttribute<Offset>()!.Value;
        }
    }

    private void BuildTypeScriptModels(DalamudPluginInterface plugin)
    {
        var location = new DirectoryInfo(Path.Combine(plugin.AssemblyLocation.DirectoryName!, "..\\ui\\src\\XIV\\Models\\Generated"));

        if (! location.Exists) {
            location.Create();
        }

        _enumTypes.Clear();

        // Remove all typescript files from this directory.
        foreach (var file in location.GetFiles("*.ts")) {
            file.Delete();
        }

        List<string> fileNames = [];

        foreach (var model in _offsets.Keys) {
            fileNames.Add(model);
            BuildTypeScriptModel(Path.Combine(location.FullName, model + ".ts"), model, _offsets[model]);
        }

        foreach (var type in _enumTypes) {
            fileNames.Add(type.Name);
            BuildTypeScriptEnum(Path.Combine(location.FullName, type.Name + ".ts"), type);
        }

        // Build index.ts file.
        var indexFile = new StreamWriter(Path.Combine(location.FullName, "index.ts"));
        indexFile.WriteLine("/* This file was generated by Lux. Do not modify. */");
        indexFile.WriteLine();
        foreach (var fileName in fileNames) {
            indexFile.WriteLine($"export * from '@/XIV/Models/Generated/{fileName}';");
        }
        indexFile.Close();
    }

    private void BuildTypeScriptModel(string fileName, string name, Dictionary<string, int> offsets)
    {
        var file = new StreamWriter(fileName);
        var type = _names.FirstOrDefault(t => t.Value == name).Key;
        
        if (null == type) {
            Logger.Error($"Type '{name}' not found.");
            return;
        }

        var defs = GetFieldDefinitionsOf(type);

        file.WriteLine("/* This file was generated by Lux. Do not modify. */");
        file.WriteLine();

        file.WriteLine("import { Offset, ModelStruct } from '@/System/Serializer';");
        
        List<string> importedTypes = [];
        foreach (var def in defs.Values) {
            if (def.IsComplexType && !importedTypes.Contains(def.TypeName)) {
                importedTypes.Add(def.TypeName);

                if (_extendedTypes.ContainsKey(def.TypeName)) {
                    file.WriteLine($"import {{ {def.TypeName} }} from '{_extendedTypes[def.TypeName]}';");
                } else {
                    file.WriteLine($"import {{ {def.TypeName} }} from '@/XIV/Models/Generated/{def.TypeName}';");
                }
            }
        }

        file.WriteLine();

        file.WriteLine($"@ModelStruct('{name}')");
        file.WriteLine($"export class {name}");
        file.WriteLine("{");

        foreach (var kvp in defs) {
            var offset    = offsets[kvp.Key];
            var def       = kvp.Value;
            var fieldName = string.Concat(def.Name[..1].ToLower(), def.Name.AsSpan(1));
            var isRO      = _extendedTypes.ContainsKey(name) ? "" : "readonly ";

            file.WriteLine($"    @Offset({offset})");
            file.WriteLine($"    public {isRO}{fieldName}{(def.isNullable ? "?" : "")}: {def.TypeName}{(def.IsArray ? "[]" : "")};");
            
            if (kvp.Key != defs.Keys.Last()) file.WriteLine();
        }

        file.WriteLine("}");
        file.Close();
    }

    private void BuildTypeScriptEnum(string fileName, Type type)
    {
        var file = new StreamWriter(fileName);

        file.WriteLine("/* This file was generated by Lux. Do not modify. */");
        file.WriteLine();

        file.WriteLine($"export enum {type.Name}");
        file.WriteLine("{");

        foreach (var value in Enum.GetValues(type)) {
            file.WriteLine($"    {value} = {Convert.ToInt32(value)},");
        }

        file.WriteLine("}");
        file.Close();
    }

    private Dictionary<string, FieldDefinition> GetFieldDefinitionsOf(Type type)
    {
        Dictionary<string, FieldDefinition> definitions = [];

        foreach (var field in type.GetFields()) {
            definitions.Add(field.Name, GetFieldDefinitionOf(field));
        }

        return definitions;
    }

    private FieldDefinition GetFieldDefinitionOf(FieldInfo field)
    {
        // Test for array types.
        if (field.FieldType.IsArray) {
            var elementType = field.FieldType.GetElementType()!;
            return GetFieldDefinitionOf(field.Name, elementType, true);
        }

        // Test for List<T>
        if (field.FieldType.IsGenericType && field.FieldType.GetGenericTypeDefinition() == typeof(List<>)) {
            var elementType = field.FieldType.GetGenericArguments()[0];
            return GetFieldDefinitionOf(field.Name, elementType, true);
        }

        if (_names.ContainsKey(field.FieldType)) {
            return GetFieldDefinitionOf(field.Name, field.FieldType, false);
        }

        return GetFieldDefinitionOf(field.Name, field.FieldType, false);
    }

    private FieldDefinition GetFieldDefinitionOf(string name, Type type, bool isArray, bool isNullable = false)
    {
        // Test for nullable types.
        if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>)) {
            var elementType = type.GetGenericArguments()[0];
            return GetFieldDefinitionOf(name, elementType, isArray, true);
        }

        if (_names.ContainsKey(type)) {
            return new FieldDefinition(name, type.Name, isArray, true, isNullable);
        }

        // Test if type is an enum.
        if (type.IsEnum) {
            if (false == _enumTypes.Contains(type)) _enumTypes.Add(type);
            return new FieldDefinition(name, type.Name, isArray, true, isNullable);
        }

        // Test for dictionaries.
        if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Dictionary<,>)) {
            var keyType = type.GetGenericArguments()[0];
            var valueType = type.GetGenericArguments()[1];

            if (keyType != typeof(string)) {
                Logger.Warning($"Unsupported dictionary key type '{keyType.Name}' for field '{name}'. Using 'any'.");
                return new FieldDefinition(name, "any", false, false, isNullable);
            }

            if (_names.ContainsKey(valueType)) {
                Logger.Warning($"Complex type '{valueType.Name}' used as dictionary value for field '{name}'.");
                return new FieldDefinition(name, "Record<string, any>", false, false, isNullable);
            }

            return new FieldDefinition(name, $"Record<string, {GetTypeScriptTypeNameOf(valueType)}>", false, false, isNullable);
        }

        return new FieldDefinition(name, GetTypeScriptTypeNameOf(type), isArray, false, isNullable);
    }

    private string GetTypeScriptTypeNameOf(Type type)
    {
        switch (type.Name) {
            case "String":
                return "string";
            case "Boolean": 
                return "boolean";
            case "Int16" :
            case "Int32" : 
            case "Int64" : 
            case "UInt16":
            case "UInt32":
            case "UInt64": 
            case "Double": 
            case "Single": 
            case "Float" : 
            case "Short" : 
            case "Byte"  :
                return "number";
            case "Object": 
                return "any";
        }

        Logger.Error($"Unknown type '{type.Name}'.");
        return "any";
    }
}

internal record FieldDefinition(string Name, string TypeName, bool IsArray, bool IsComplexType, bool isNullable);